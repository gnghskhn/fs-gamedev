#summary Efficient generic programming

= Efficient generic programming =

== Introduction ==

Beside being fun, generic programming also helps code reuse. Unfortunately, this kind of benefits often comes at a price, namely a suboptimal execution speed.

Consider for instance this line from the `runge_kutta_4` function in the series of tutorials:

{{{
old + (1.0/6.0) * (v1 + 2.0 * (v2 + v3) + v4)
}}}

The code produced by the compiler is equivalent to

{{{
tmp1 = v2 + v3
tmp2 = 2.0 * tmp1
tmp3 = tmp2 + v4
tmp5 = v1 + tmp3
tmp6 = 1.0 / 6.0
tmp7 = tmp6 * tmp5
old + tmp7
}}}

There are 7 intermediate values, but because of their short life time, they could all be stored in one single variable.

When dealing with primitive types, such as `float`, the compiler or the run-time will produce optimized code using few variables.

However, when classes or structs are used, these optimizations are no longer performed. For example, if `old`, `v1`, `v2`, `v3` and `v4` are 3 dimensional vectors implemented using a `Vec3d` class, a new instance will be created for each temporary value, resulting in many calls to the class' constructor.

== Code ==

The full code is available in the [http://code.google.com/p/fs-gamedev/source/browse/trunk/Tutorial011/Program011.fs repository]. Note that this code is no longer the full integration example for earlier tutorials. Parts of `runge_kutta_4` were extracted, and the rest was thrown away, for clarity and conciseness matters.

We now focus on the interesting bits.

{{{
// Addition of many vectors: avoid creating vectors for each intermediate result.
let add6 ((v0: Vec3d), (v1: Vec3d), (v2: Vec3d), (v3: Vec3d), (v4: Vec3d), (v5: Vec3d)) =
    let x = v0.x + v1.x + v2.x + v3.x + v4.x + v5.x
    let y = v0.y + v1.y + v2.y + v3.y + v4.y + v5.y
    let z = v0.z + v1.z + v2.z + v3.z + v4.z + v5.z
    
    Vec3d(x, y ,z)
}}}

This function computes the sum of 6 vectors using `float`s instead of `Vec3d` to hold intermediate results.
Admittedly, it's not very pretty, and it would be nice if the user of `runge_kutta_4` was not forced to provide such an ugly function.

The problem is now how to modify `runge_kutta_4` to use this `add6` function if the user so wishes. The function `average2` below computes the last steps of `runge_kutta_4`.

{{{
let inline average2 (scale: float * 'vec -> 'vec) (add: 'vec * 'vec -> 'vec) (add6: 'vec Add6 option) old v1 v2 v3 v4 =
    let (*) k v = scale(k, v)
    let (+) u v = add(u, v)
    
    match add6 with
    // No addMany available, use pair-wise additions (will create many intermediate vectors).
    | None ->
        old + (1.0/6.0) * (v1 + 2.0 * (v2 + v3) + v4)
    // addMany available, use it.
    | Some addM ->
        let tmp = addM(v1, v2, v2, v3, v3, v4)
        old + (1.0/6.0) * tmp
}}}

This is a new F# construct, called "pattern-matching". Basically, it means:

"Check the value of `add6`. If it is equal to `None`, then do the sum the usual way. otherwise, if the value of `add6` is _of the form_ `Some add`, then do the sum by using `add`".

I think pattern matching is a very nice construct. It allows you to match a value with fairly complex expressions called patterns. I won't dig deeper into patterns yet, let me just say that even though they look complex, the code generated by the compiler is as optimized as possible.

It may seem that this code isn't optimal, as the value of `add6` is checked every time this function is called.

{{{
let average2_Vec3d = average2 scale_Vec3d plus_Vec3d (Some add6)
let average2_Vec3d' = average2 scale_Vec3d plus_Vec3d None
}}}

However, using partial application and closures, we can help the F# compiler generate the code we want, i.e. remove the test for add6. See for yourself in the screenshots of reflector, below.

With `add6`:
http://3.bp.blogspot.com/_nDGpBaX7_xg/STFm1pONmcI/AAAAAAAAAfo/yUVps0xG7WY/s1600-h/FS-Tut11b-1.png

Without `add6`:
http://2.bp.blogspot.com/_nDGpBaX7_xg/STFm_lQs8rI/AAAAAAAAAfw/ZCoihkiUt_Y/s1600-h/FS-Tut11b-2.png

*Note* images don't show up, I don't know why >:(

== A negative note ==

The text above shows a function called `average2`. The curious reader may wonder what happened with `average`? There is indeed a function called `average`, similar to `average2` with the exception that it uses a dictionary of operations instead of explicit parameters.

{{{
// Dictionary of operations.
type VecOps<'vector, 'scalar> = {
    up: 'vector
    add: 'vector * 'vector -> 'vector
    add6: Add6<'vector> option
    scale: 'scalar * 'vector -> 'vector
}

// Final step in runge-kutta 4
let inline average (vec_ops: VecOps<_, _>) old v1 v2 v3 v4 =
}}}

Partial application and closures are also used to produce optimized versions:

{{{
// "average" instantiated for Vec3d, with specialized addition of 6 vectors.
let average_Vec3d = average Vec3d_ops 
// "average" instantiated for Vec3d, without specialized addition of 6 vectors.
let average_Vec3d' = average {Vec3d_ops with add6 = None} 
}}}

The problem is that the resulting code is not optimized (using the currently available version of the F# compiler, 1.9.6.2). It seems that in order to be sure the compiler produces optimized code, one must stay away from dictionary of operations. I think it's a shame, but maybe that's an issue that will be addressed in future versions of the compiler.

== Conclusion ==

I get a 25% performance boost thanks to "add6" when using 3d vectors. On the other hand, I get a 65% performance drop when summing floats. This seems to be a clear case where tailoring generic code to specific types really helps to achieve the best performance.

Time to conclude the part of these tutorials dedicated to generic programming and low-level optimization.

To summarize:
1) Avoid curried functions when performance is critical, especially for methods.
2) Inline generic functions to avoid indirect calls to operations. However, do not take the habit of inlining all small functions. The compiler or the CLR do that for you.
3) Keep dictionaries of operations small, or avoid them altogether. Alternatives include static [http://sharp-gamedev.blogspot.com/2008/09/tutorial-9-generic-programming-using.html type constraints], or function parameters.